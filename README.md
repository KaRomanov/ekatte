# EKATTE

## Цел

Целта на проекта е:

* Да се създаде база данни съдържаща всички селища, кметства, общини и области в България, като се използва информацията от EKATTE (EKATTE файлове). Базата данни трябва да бъде в трета нормална форма (3NF), с правилно дефинирани primary и foreign keys, индекси и constraints.
* Да се напише програма, която да импортира данните от ЕКАТТЕ файловете в базата данни.
* Да се разработи уеб интерфейс през който да се търси информация за съществуващите селища

## Използвани технологии

* JavaScript/ NodeJS
* PostgreSQL

## Използвани библиотеки

* `jest` - за unit тестове
* `jest-fetch-mock` - за симулация на fetch при тестовете
* `pg` (node-postgres) - за връзка с базата данни
* `dotenv` - за променливи на средата

## Структура

В папката __`./db`__ се съдържа скриптът за инициализирането на базата и модулът отговорен за връзката с базата и правенето на заявки

В папката __`./src`__ се запазват изтеглените файлове, от които си извичаме информацията

В папката __`./tests`__ се съдържат тестовете за модулите и функции

## Как работи

### Теглене на файлове

Модулът __`downloadFiles.js`__ отговаря за това. 

Имаме функция__`getFile`__, която приема линк за файла и дестинация. По принцип файловете, който на нас ни трябват не надвишават __2,5 MB__, така че можем да си позволим да ги заредим в памет и да ги запазим. Имплементацията тук го прави чрез __fetch__ към линка за файла, който получава __json__ отговор и файла го получаваме в тялото на отговора. Функцията ни връща __Promise__ и така разбираме, кога файлът е изтеглен и готов за четене.

__`downloadFiles`__ функцията ни приема масив от линкове за файлове и дестинации. За всеки файл от масива извикваме функцията __`getFile`__ за взимане на файл.

### Връзка с базата и изпълняване на заявки

Модулът __`./db/index.js`__ отговаря за връзката с базата и изпълнението на заявки.
Тук използваме променливите на средата в папката __`.env`__
```
PGUSER=
PGPASSWORD=
PGHOST=
PGPORT=
PGDATABASE=
```
Създаваме си обект __pool__, който ни управлява връзките с базата.

Имаме функция __query__, която приема заявка и аргументи. Хващаме грешка, ако има от заявката.

Имаме и функция __end__, която ни прекратява връзката с базата.

### Качване на данните в базата

Логиката за качване на данните от файловете към базата се съдържа в __`updateDB`__. 
Идеята е да изтрием всичко от таблиците досега и да попълним данните от файловете за региони, общини, кметства и селища. 

За всяка една таблица си четем файла и филтрираме стойностите да сме сигурни, че са валидни, после правим трансформация на данните, ако се налага, и получаваме масив с вече валидните данни. Така за всеки елемент от масива минаваме и изпълняваме заявка за качване в базата.

В една транзакция е сложено всичко това, така че ако стане грешка по време на изпълнението просто правим *rollback* и връщаме състоянието на базата. Преди да започнем да слагаме в базата, затриваме всички предишни данни, за да осигурим, че няма да има стари останали.

По начина, по който е направено в момента, всяка заявка изчаква предишната преди да се изпълни и за всеки отделен обект правим по една заявка. Понеже нямаме много количество данни (около 9000) и в бъдеще числото няма да се промени, това решение е достатъчно, като отнема около __2,5__ секунди за изпълнението на локална машина.

### Изпълняване на скрипта
